"""
generate_diksha_connector.py - DIKSHA Content Connector Generator
==================================================================

Generates a complete Fivetran connector from diksha_content.json

Usage:
    python generate_diksha_connector.py

Generates:
    - connector.py (complete DIKSHA connector)
    - requirements.txt

Author: Bharat Connect Team
Date: 2025-10-25
"""

import json
import os
from datetime import datetime

# ============================================================================
# CONFIGURATION
# ============================================================================

DIKSHA_FILE = 'diksha_content.json'
OUTPUT_FILE = 'connector.py'
REQUIREMENTS_FILE = 'requirements.txt'

# ============================================================================
# CONNECTOR TEMPLATE
# ============================================================================

CONNECTOR_TEMPLATE = '''"""
connector.py - Bharat Connect DIKSHA Connector
===============================================
AUTO-GENERATED by generate_diksha_connector.py
Generated: {generation_time}

DO NOT EDIT THIS FILE MANUALLY!
Run: python generate_diksha_connector.py to regenerate

Features:
- Ingests DIKSHA educational content metadata
- Multi-language support ({languages})
- Board/Grade/Subject tracking
- Direct content ingestion (no API calls during sync)

Content: {content_count} educational resources
Boards: {boards}
Languages: {languages}
"""

from fivetran_connector_sdk import Connector
from fivetran_connector_sdk import Operations as op
from datetime import datetime, timezone
import hashlib
from typing import Dict

# ============================================================================
# DIKSHA CONTENT DATA
# ============================================================================
# Auto-generated from: {diksha_file}
# Total content: {content_count}
# Discovery timestamp: {discovery_time}

DIKSHA_CONTENT = {content_data}

# ============================================================================
# METADATA
# ============================================================================

CONTENT_STATS = {{
    'total_content': {content_count},
    'by_language': {language_stats},
    'by_board': {board_stats},
    'by_grade': {grade_stats},
    'by_subject': {subject_stats}
}}

# ============================================================================
# TABLE SCHEMA
# ============================================================================

TABLE_NAME = 'diksha_content'

SCHEMA = [{{
    'table': TABLE_NAME,
    'primary_key': ['content_id'],
    'columns': {{
        'content_id': 'STRING',
        'title': 'STRING',
        'description': 'STRING',
        'content_type': 'STRING',
        'primary_category': 'STRING',
        'mime_type': 'STRING',
        'board': 'STRING',
        'grade_level': 'JSON',
        'subject': 'JSON',
        'language': 'JSON',
        'medium': 'JSON',
        'diksha_url': 'STRING',
        'framework': 'STRING',
        'channel': 'STRING',
        'status': 'STRING',
        'created_on': 'STRING',
        'last_updated_on': 'STRING',
        'ingested_at': 'UTC_DATETIME',
        'source': 'STRING'
    }}
}}]

# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

def format_list_field(data):
    """Convert list to JSON-safe format."""
    if isinstance(data, list):
        return data
    if isinstance(data, str):
        return [data]
    return []

# ============================================================================
# SCHEMA FUNCTION
# ============================================================================

def schema(configuration: dict):
    return SCHEMA

# ============================================================================
# UPDATE FUNCTION
# ============================================================================

def update(configuration: dict, state: dict):
    """
    Main sync engine - ingests DIKSHA content from embedded data.
    This is a one-time full sync of discovered educational content.
    """
    
    if not DIKSHA_CONTENT:
        print("No DIKSHA content to ingest")
        return
    
    print(f"Starting DIKSHA content ingestion")
    print(f"   Total content items: {{len(DIKSHA_CONTENT)}}")
    print(f"   Statistics:")
    for key, val in CONTENT_STATS.items():
        if key != 'total_content':
            print(f"     {{key}}: {{len(val)}} categories")
    
    # State management
    seen_ids = set(state.get(TABLE_NAME, {{}}).get('seen_ids', []))
    new_seen_ids = seen_ids.copy()
    
    current_time = datetime.now(timezone.utc)
    total_upserts = 0
    total_skipped = 0
    
    # Process each content item
    for idx, item in enumerate(DIKSHA_CONTENT, 1):
        content_id = item.get('content_id')
        
        if not content_id:
            print(f"   Skipping item {{idx}}: No content_id")
            total_skipped += 1
            continue
        
        # Skip if already ingested
        if content_id in seen_ids:
            total_skipped += 1
            continue
        
        # Format arrays
        record = {{
            'content_id': content_id,
            'title': item.get('title', ''),
            'description': item.get('description', ''),
            'content_type': item.get('content_type', ''),
            'primary_category': item.get('primary_category', ''),
            'mime_type': item.get('mime_type', ''),
            'board': item.get('board', ''),
            'grade_level': format_list_field(item.get('grade_level', [])),
            'subject': format_list_field(item.get('subject', [])),
            'language': format_list_field(item.get('language', [])),
            'medium': format_list_field(item.get('medium', [])),
            'diksha_url': item.get('diksha_url', ''),
            'framework': item.get('framework', ''),
            'channel': item.get('channel', ''),
            'status': item.get('status', ''),
            'created_on': item.get('created_on', ''),
            'last_updated_on': item.get('last_updated_on', ''),
            'ingested_at': current_time.isoformat(),
            'source': 'DIKSHA'
        }}
        
        yield op.upsert(TABLE_NAME, record)
        new_seen_ids.add(content_id)
        total_upserts += 1
        
        # Progress indicator
        if idx % 100 == 0:
            print(f"   Progress: {{idx}}/{{len(DIKSHA_CONTENT)}} ({{total_upserts}} new)")
    
    print(f"\\n{{'='*60}}")
    print(f"DIKSHA Ingestion Complete:")
    print(f"  Total upserted: {{total_upserts}}")
    print(f"  Total skipped (duplicates): {{total_skipped}}")
    print(f"  Content types: {{', '.join(CONTENT_STATS['by_language'].keys())}}")
    print(f"{{'='*60}}")
    
    # Trim seen_ids
    if len(new_seen_ids) > 10000:
        new_seen_ids = set(list(new_seen_ids)[-10000:])
    
    # Save state
    new_state = {{
        TABLE_NAME: {{
            'seen_ids': list(new_seen_ids),
            'last_sync': current_time.isoformat()
        }}
    }}
    
    yield op.checkpoint(new_state)

# ============================================================================
# REGISTER CONNECTOR
# ============================================================================

connector = Connector(update=update, schema=schema)

if __name__ == '__main__':
    connector.run()
'''

# ============================================================================
# GENERATOR FUNCTIONS
# ============================================================================

def load_diksha_content(json_file=DIKSHA_FILE):
    """Load DIKSHA content JSON."""
    if not os.path.exists(json_file):
        raise FileNotFoundError(
            f"{json_file} not found!\\n"
            f"   Run DIKSHA discovery agent first: python diksha_discovery_agent.py"
        )
    
    with open(json_file, 'r', encoding='utf-8') as f:
        return json.load(f)

def format_content_data(content_list):
    """Format content list as Python code."""
    # Use json.dumps for clean formatting
    import json as j
    return j.dumps(content_list, indent=2, ensure_ascii=False)

def generate_connector(diksha_data):
    """Generate complete connector.py content."""
    
    metadata = diksha_data.get('metadata', {})
    content = diksha_data.get('content', [])
    stats = metadata.get('statistics', {})
    
    # Extract summary info
    languages = ', '.join(stats.get('by_language', {}).keys())
    boards = ', '.join(stats.get('by_board', {}).keys())
    
    return CONNECTOR_TEMPLATE.format(
        generation_time=datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
        content_count=len(content),
        languages=languages,
        boards=boards,
        diksha_file=DIKSHA_FILE,
        discovery_time=metadata.get('timestamp', 'Unknown'),
        content_data=format_content_data(content),
        language_stats=stats.get('by_language', {}),
        board_stats=stats.get('by_board', {}),
        grade_stats=stats.get('by_grade', {}),
        subject_stats=stats.get('by_subject', {})
    )

def generate_requirements():
    """Generate requirements.txt (no special packages needed for DIKSHA)."""
    return ""  # Empty - no extra packages needed

# ============================================================================
# MAIN
# ============================================================================

if __name__ == '__main__':
    print("=" * 70)
    print(" " * 15 + "DIKSHA CONNECTOR GENERATOR")
    print("=" * 70)
    
    try:
        # Step 1: Load DIKSHA content
        print(f"\\nStep 1: Loading {DIKSHA_FILE}...")
        data = load_diksha_content(DIKSHA_FILE)
        
        metadata = data.get('metadata', {})
        content = data.get('content', [])
        stats = metadata.get('statistics', {})
        
        print(f"   Found {len(content)} educational resources")
        print(f"   Statistics:")
        print(f"      Languages: {', '.join(stats.get('by_language', {}).keys())}")
        print(f"      Boards: {', '.join(stats.get('by_board', {}).keys())}")
        print(f"      Grades: {len(stats.get('by_grade', {}))} levels")
        
        # Step 2: Generate connector.py
        print(f"\\nStep 2: Generating {OUTPUT_FILE}...")
        connector_code = generate_connector(data)
        
        with open(OUTPUT_FILE, 'w', encoding='utf-8') as f:
            f.write(connector_code)
        print(f"   Generated {OUTPUT_FILE} ({len(connector_code)} bytes)")
        
        # Step 3: Generate requirements.txt
        print(f"\\nStep 3: Generating {REQUIREMENTS_FILE}...")
        requirements = generate_requirements()
        
        with open(REQUIREMENTS_FILE, 'w', encoding='utf-8') as f:
            f.write(requirements)
        print(f"   Generated {REQUIREMENTS_FILE} (no extra packages needed)")
        
        # Step 4: Preview
        print("\\nContent Preview (by type):")
        content_types = {}
        for item in content[:10]:
            ct = item.get('content_type', 'Unknown')
            content_types[ct] = content_types.get(ct, 0) + 1
        
        for ct, count in list(content_types.items())[:5]:
            print(f"   - {ct}: {count} items")
        
        # Step 5: Next steps
        print(f"\\n{'=' * 70}")
        print("DIKSHA connector generated successfully!")
        print("\\nNext steps:")
        print("   1. Test locally:")
        print("      $ fivetran reset")
        print("      $ fivetran debug")
        print("\\n   2. Deploy to Fivetran:")
        print("      $ fivetran deploy --api-key <KEY>")
        print("                       --destination bc_bigquery")
        print("                       --connection diksha_connector")
        print("=" * 70)
        
    except FileNotFoundError as e:
        print(f"\\nError: {e}")
        exit(1)
    except Exception as e:
        print(f"\\nUnexpected error: {e}")
        import traceback
        traceback.print_exc()
        exit(1)
